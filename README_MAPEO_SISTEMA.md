# MAPEO COMPLETO DEL SISTEMA DE SIMULACI√ìN
## Flujo de Ejecuci√≥n End-to-End con Nombres de Funciones

> **Documentaci√≥n T√©cnica Completa**  
> Sistema de simulaci√≥n de detectabilidad de supernovas  
> Pipeline desde CLI hasta resultados cient√≠ficos finales

---

## üìã **RESUMEN EJECUTIVO - FLUJO COMPLETO**

### **üéØ Pipeline End-to-End en 5 Niveles:**

**1. ENTRADA CLI** ‚Üí **2. CONFIGURACI√ìN** ‚Üí **3. MUESTREO CIENT√çFICO** ‚Üí **4. PIPELINE F√çSICO** ‚Üí **5. AGREGACI√ìN ESTAD√çSTICA**

### **üîç Secuencia Detallada de Ejecuci√≥n:**

1. **`simple_runner.py`** inicia el sistema:
   - **Importa funciones**: `create_simple_config()` desde el archivo `simple_config.py`
   - **Funci√≥n `create_simple_config()`**: Retorna un objeto de clase `SimpleConfig` con par√°metros validados
   - **Ejecuta `main()` [simple_runner.py]**: Entry point principal del sistema
     - **`parse_arguments()` [SE EJECUTA DENTRO DE main()]**: Parsea argumentos CLI
     - **`setup_environment()` [SE EJECUTA DENTRO DE main()]**: **CREA CARPETAS** para preparar las salidas en `outputs/` (single_runs/, batch_runs/, logs/, etc.)
     - **`run_custom_batch()` [SE EJECUTA DENTRO DE main()]**: Recibe inputs de los par√°metros de l√≠nea de comandos parseados

2. **Transici√≥n a Batch Runner:**
   - **Dentro de `run_custom_batch()` [simple_runner.py]**: Se crea la config con `create_simple_config()` usando par√°metros CLI
   - **Con la config creada [DENTRO DE run_custom_batch()]**: Se ejecuta `run_scientific_batch(config)` 
   - **Se transfiere control**: Del archivo `simple_runner.py` al archivo `batch_runner.py`
   - **`run_scientific_batch()` [batch_runner.py]**: Funci√≥n wrapper que instancia `ProfessionalBatchRunner()` 
     - **`run_batch()` [SE EJECUTA DENTRO DE run_scientific_batch()]**: M√©todo principal del batch runner

3. **Generaci√≥n de Par√°metros Cient√≠ficos**:
   - **`run_batch()` [ProfessionalBatchRunner]**: Loop principal de iteraciones
     - **`create_run_parameters()` [SE EJECUTA DENTRO DE run_batch()]**: Muestreo cient√≠fico por iteraci√≥n
       - **`sample_cosmological_redshift()` [SE EJECUTA DENTRO DE create_run_parameters()]**: Muestreo cosmol√≥gico volume-weighted
       - **`sample_extinction_by_type()` [SE EJECUTA DENTRO DE create_run_parameters()]**: Distribuciones acad√©micas por tipo SN
       - **`get_sn_templates()` [SE EJECUTA DENTRO DE create_run_parameters()]**: Obtiene templates disponibles
       - **`np.random.choice(available_templates)` [SE EJECUTA DENTRO DE create_run_parameters()]**: Selecci√≥n **ALEATORIA** del template
       - **`sample_realistic_mw_extinction()` [SE EJECUTA DENTRO DE create_run_parameters()]**: Extinci√≥n MW que llama **INTERNAMENTE**:
         - Muestrear coordenadas de ZTF (actualmente sint√©ticas)
         - Consultar mapas de extinci√≥n realistas SFD98
         - **NOTA FUTURA**: No usa coordenadas reales del objeto ZTF pero ser√≠a bueno implementarlo
   - **Resultado**: Finalmente tenemos **TODOS** los par√°metros guardados en `iteration_params`

4. **Ejecuci√≥n Individual**:
   - **`execute_single_run()` [SE EJECUTA DENTRO DE run_batch()]**: Recibe `iteration_params`
     - **`update_config_for_run()` [SE EJECUTA DENTRO DE execute_single_run()]**: **ACTUALIZA** los par√°metros de `config.py` global
     - **`load_and_validate_config()` [SE EJECUTA DENTRO DE execute_single_run()]**: Confirma que no haya errores en configuraci√≥n
     - **`import main` [SE EJECUTA DENTRO DE execute_single_run()]**: Importa el m√≥dulo main.py
     - **`main.main(config=validated_config)` [SE EJECUTA DENTRO DE execute_single_run()]**: Llamada al pipeline cient√≠fico

5. **Pipeline Cient√≠fico Completo** (en `main.py` viene TODO el pipeline de proyecci√≥n):
   - **`main()` [main.py]**: Funci√≥n principal del pipeline cient√≠fico
     - **PASO 1 [SE EJECUTA DENTRO DE main()]**: **LEE LOS ESPECTROS**
       - **`leer_spec()` [SE EJECUTA EN PASO 1]**: Lee archivo de template seleccionado
     - **PASO 2 [SE EJECUTA DENTRO DE main()]**: **APLICA CORRECCIONES COSMOL√ìGICAS**
       - **`correct_redeening()` [SE EJECUTA EN PASO 2]**: Aplica redshift + extinci√≥n f√≠sica
     - **PASO 3 [SE EJECUTA DENTRO DE main()]**: **CARGA RESPUESTA DE FILTRO**
       - **`pd.read_csv(path_response)` [SE EJECUTA EN PASO 3]**: Carga curva respuesta fotom√©trica
     - **PASO 4 [SE EJECUTA DENTRO DE main()]**: **FOTOMETR√çA SINT√âTICA**
       - **`Syntetic_photometry_v2()` [SE EJECUTA EN PASO 4]**: Overlap 95% entre espectro y filtro
     - **PASO 5 [SE EJECUTA DENTRO DE main()]**: **SUAVIZADO LOESS**
       - **`Loess_fit()` [SE EJECUTA EN PASO 5]**: Interpolaci√≥n estad√≠stica de curva de luz
     - **PASO 6 [SE EJECUTA DENTRO DE main()]**: **CALIBRACI√ìN FOTOM√âTRICA**
       - **Conversi√≥n flujo ‚Üí magnitudes [SE EJECUTA EN PASO 6]**: Usando constantes de punto cero
     - **PASO 7 [SE EJECUTA DENTRO DE main()]**: **RUIDO FOTOM√âTRICO**
       - **`np.random.normal()` [SE EJECUTA EN PASO 7]**: Simula Poisson + Gaussiana
     - **PASO 7.5 [SE EJECUTA DENTRO DE main()]**: **CONVERSI√ìN TEMPORAL CR√çTICA**
       - **`maximo_lc()` [SE EJECUTA EN PASO 7.5]**: Obtiene MJD del m√°ximo
       - **Conversi√≥n fases ‚Üí MJD [SE EJECUTA EN PASO 7.5]**: Para SNe core-collapse

6. **‚ö†Ô∏è Bug Temporal Resuelto** (Paso 7.5 - DETALLES COMPLETOS):
   ```python
   # DATOS DE ENTRADA (antes del PASO 7.5):
   fases = [-10, 0, +20]     # ‚Üê Fases relativas (d√≠as respecto al m√°ximo)
   maximum = 53671           # ‚Üê MJD absoluto del m√°ximo (funci√≥n maximo_lc)
   mjd_pivote = 59000       # ‚Üê MJD de observaciones modernas ZTF

   # C√ÅLCULO ERR√ìNEO:
   desplazamiento = 59000 - 53671 + offset ‚âà 5329 d√≠as
   fases_ajustadas = [-10 + 5329, 0 + 5329, +20 + 5329]
                   = [5319, 5329, 5349]  # ‚Üê ¬°Fechas imposibles a√±o 1846!
   
   # SOLUCI√ìN: Conversi√≥n expl√≠cita antes de proyecci√≥n
   if tipo in ['Ibc', 'Ib', 'Ic']:
       mjd_absolute = maximum + lc_df['fase']  # Fases ‚Üí MJD absoluto
       lc_df['fase'] = mjd_absolute           # Actualizar DataFrame
   ```

     - **PASO 8 [SE EJECUTA DENTRO DE main()]**: **PROYECCI√ìN TEMPORAL**
       - **`field_projection()` [SE EJECUTA EN PASO 8]**: Proyecci√≥n sobre observaciones reales del survey
         - **`maximo_lc()` [SE EJECUTA DENTRO DE field_projection()]**: Calcula m√°ximo de la SN
         - **`interpolate.interp1d()` [SE EJECUTA DENTRO DE field_projection()]**: Interpola magnitudes en tiempos observaci√≥n
     - **PASO 9 [SE EJECUTA DENTRO DE main()]**: **RESUMEN CON M√âTRICAS**
       - **C√°lculo detecciones/upper limits [SE EJECUTA EN PASO 9]**: An√°lisis de detectabilidad
     - **PASO 10 [SE EJECUTA DENTRO DE main()]**: **GUARDAR RESULTADOS**
       - **`save_projection_results()` [SE EJECUTA EN PASO 10]**: Persistencia individual
     - **PASO 11 [SE EJECUTA DENTRO DE main()]**: **ACTUALIZAR √çNDICE**
       - **`create_master_index()` [SE EJECUTA EN PASO 11]**: Actualizaci√≥n √≠ndice maestro

7. **Lo que pasa DESPU√âS de main** (retorno y extracci√≥n de resultados):
   - **RETORNO A `execute_single_run()` [batch_runner.py]**: Despu√©s de completar main.main()
     - **`extract_run_statistics()` [SE EJECUTA DENTRO DE execute_single_run()]**: Busca CSV generado por `save_projection_results()`
       - **`glob.glob()` [SE EJECUTA DENTRO DE extract_run_statistics()]**: Busca archivos summary m√°s recientes
       - **`pd.read_csv()` [SE EJECUTA DENTRO DE extract_run_statistics()]**: Lee m√©tricas reales del CSV
     - **Retorna estad√≠sticas confirmadas [DESDE execute_single_run()]**: No estimadas, sino valores reales
     - **Timing de ejecuci√≥n [EN execute_single_run()]**: Se calcula tiempo total de la iteraci√≥n

8. **Agregaci√≥n por Batch** (retorno a `run_batch()`):
   - **RETORNO A `run_batch()` [ProfessionalBatchRunner]**: Despu√©s de execute_single_run()
     - **`add_successful_run()` [SE EJECUTA DENTRO DE run_batch()]**: Acumula estad√≠sticas globales
       - **Suma detecciones totales [DENTRO DE add_successful_run()]**: Acumulaci√≥n estad√≠stica
       - **Actualiza distribuciones por tipo [DENTRO DE add_successful_run()]**: Para an√°lisis cient√≠fico
     - **Registro en `run_registry` [DENTRO DE run_batch()]**: Lista completa con TODAS las iteraciones

9. **Persistencia Final**:
   - **AL FINAL DE `run_batch()` [ProfessionalBatchRunner]**: Despu√©s del loop de iteraciones
     - **`save_batch_results()` [SE EJECUTA DENTRO DE run_batch()]**: Guardado agregado final
       - **`json.dump(batch_metadata)` [SE EJECUTA DENTRO DE save_batch_results()]**: Guarda configuraci√≥n completa
       - **`df_runs.to_csv()` [SE EJECUTA DENTRO DE save_batch_results()]**: CSV con todas las iteraciones
       - **Generaci√≥n de reportes [DENTRO DE save_batch_results()]**: Archivos de resumen estad√≠stico

### **üéØ Resultado Final:**
- **Simulaciones individuales** con reproducibilidad total
- **Estad√≠sticas agregadas** publication-ready
- **Trazabilidad completa** desde CLI hasta m√©tricas cient√≠ficas
- **Sistema robusto** con fallbacks y validaci√≥n en cada nivel

---

## ÔøΩ **MAPEO JER√ÅRQUICO COMPLETO DE FUNCIONES**

### **üìã Mapeo Espec√≠fico de Funciones por Archivo**

#### **`simple_runner.py`** - Entry Point y Control CLI
```python
main()                           # Entry point principal del sistema
‚îú‚îÄ‚îÄ parse_arguments()            # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ setup_environment()          # [EJECUTA DENTRO DE main()] - Crea estructura de carpetas
‚îî‚îÄ‚îÄ run_custom_batch()           # [EJECUTA DENTRO DE main()] - Coordina ejecuci√≥n batch
    ‚îú‚îÄ‚îÄ create_simple_config()   # [EJECUTA DENTRO DE run_custom_batch()]
    ‚îî‚îÄ‚îÄ run_scientific_batch()   # [EJECUTA DENTRO DE run_custom_batch()]
```

#### **`batch_runner.py`** - Coordinaci√≥n de Batch y Muestreo Cient√≠fico
```python
run_scientific_batch(config)                           # Wrapper function
‚îî‚îÄ‚îÄ ProfessionalBatchRunner.run_batch()                # [EJECUTA DENTRO DE run_scientific_batch()]
    ‚îú‚îÄ‚îÄ create_run_parameters()                        # [EJECUTA DENTRO DE run_batch()]
    ‚îÇ   ‚îú‚îÄ‚îÄ sample_cosmological_redshift()             # [EJECUTA DENTRO DE create_run_parameters()]
    ‚îÇ   ‚îú‚îÄ‚îÄ sample_extinction_by_type()                # [EJECUTA DENTRO DE create_run_parameters()]  
    ‚îÇ   ‚îú‚îÄ‚îÄ get_sn_templates()                         # [EJECUTA DENTRO DE create_run_parameters()]
    ‚îÇ   ‚îú‚îÄ‚îÄ np.random.choice(available_templates)      # [EJECUTA DENTRO DE create_run_parameters()]
    ‚îÇ   ‚îî‚îÄ‚îÄ sample_realistic_mw_extinction()           # [EJECUTA DENTRO DE create_run_parameters()]
    ‚îÇ       ‚îú‚îÄ‚îÄ sample_ztf_coordinates()               # [EJECUTA DENTRO DE sample_realistic_mw_extinction()]
    ‚îÇ       ‚îî‚îÄ‚îÄ query_sfd98_extinction_maps()          # [EJECUTA DENTRO DE sample_realistic_mw_extinction()]
    ‚îú‚îÄ‚îÄ execute_single_run(iteration_params)           # [EJECUTA DENTRO DE run_batch()]
    ‚îÇ   ‚îú‚îÄ‚îÄ update_config_for_run()                    # [EJECUTA DENTRO DE execute_single_run()]
    ‚îÇ   ‚îú‚îÄ‚îÄ load_and_validate_config()                 # [EJECUTA DENTRO DE execute_single_run()]
    ‚îÇ   ‚îú‚îÄ‚îÄ main.main(config=validated_config)         # [EJECUTA DENTRO DE execute_single_run()]
    ‚îÇ   ‚îî‚îÄ‚îÄ extract_run_statistics()                   # [EJECUTA DENTRO DE execute_single_run()]
    ‚îÇ       ‚îú‚îÄ‚îÄ glob.glob()                            # [EJECUTA DENTRO DE extract_run_statistics()]
    ‚îÇ       ‚îî‚îÄ‚îÄ pd.read_csv()                          # [EJECUTA DENTRO DE extract_run_statistics()]
    ‚îú‚îÄ‚îÄ add_successful_run()                           # [EJECUTA DENTRO DE run_batch()]
    ‚îÇ   ‚îú‚îÄ‚îÄ accumulate_detection_stats()               # [EJECUTA DENTRO DE add_successful_run()]
    ‚îÇ   ‚îî‚îÄ‚îÄ update_type_distributions()                # [EJECUTA DENTRO DE add_successful_run()]
    ‚îî‚îÄ‚îÄ save_batch_results()                           # [EJECUTA DENTRO DE run_batch()]
        ‚îú‚îÄ‚îÄ json.dump(batch_metadata)                  # [EJECUTA DENTRO DE save_batch_results()]
        ‚îú‚îÄ‚îÄ df_runs.to_csv()                           # [EJECUTA DENTRO DE save_batch_results()]
        ‚îî‚îÄ‚îÄ generate_summary_reports()                 # [EJECUTA DENTRO DE save_batch_results()]
```

#### **`main.py`** - Pipeline Cient√≠fico (11 Pasos)
```python
main(config)                                          # Pipeline cient√≠fico principal
‚îú‚îÄ‚îÄ PASO 1: leer_spec()                               # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 2: correct_redeening()                       # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 3: pd.read_csv(path_response)                # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 4: Syntetic_photometry_v2()                  # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 5: Loess_fit()                               # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 6: flujo_to_magnitudes()                     # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 7: np.random.normal()                        # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 7.5: temporal_conversion_critical()          # [EJECUTA DENTRO DE main()]
‚îÇ   ‚îú‚îÄ‚îÄ maximo_lc()                                   # [EJECUTA DENTRO DE temporal_conversion_critical()]
‚îÇ   ‚îî‚îÄ‚îÄ phase_to_mjd_conversion()                     # [EJECUTA DENTRO DE temporal_conversion_critical()]
‚îú‚îÄ‚îÄ PASO 8: field_projection()                        # [EJECUTA DENTRO DE main()]
‚îÇ   ‚îú‚îÄ‚îÄ maximo_lc()                                   # [EJECUTA DENTRO DE field_projection()]
‚îÇ   ‚îî‚îÄ‚îÄ interpolate.interp1d()                        # [EJECUTA DENTRO DE field_projection()]
‚îú‚îÄ‚îÄ PASO 9: calculate_detection_metrics()             # [EJECUTA DENTRO DE main()]
‚îú‚îÄ‚îÄ PASO 10: save_projection_results()                # [EJECUTA DENTRO DE main()]
‚îî‚îÄ‚îÄ PASO 11: create_master_index()                    # [EJECUTA DENTRO DE main()]
```

#### **`core/correction.py`** - Funciones de Correcci√≥n F√≠sica
```python
correct_redeening()                                   # Correcciones cosmol√≥gicas principales
‚îú‚îÄ‚îÄ apply_redshift_correction()                       # [EJECUTA DENTRO DE correct_redeening()]
‚îú‚îÄ‚îÄ apply_host_extinction()                           # [EJECUTA DENTRO DE correct_redeening()]
‚îî‚îÄ‚îÄ apply_mw_extinction()                             # [EJECUTA DENTRO DE correct_redeening()]
```

#### **`core/utils.py`** - Utilidades y Proyecci√≥n
```python
field_projection()                                    # Proyecci√≥n temporal sobre observaciones
‚îú‚îÄ‚îÄ load_ztf_observations()                          # [EJECUTA DENTRO DE field_projection()]
‚îú‚îÄ‚îÄ maximo_lc()                                       # [EJECUTA DENTRO DE field_projection()]
‚îú‚îÄ‚îÄ interpolate_magnitudes()                          # [EJECUTA DENTRO DE field_projection()]
‚îî‚îÄ‚îÄ calculate_detectability()                         # [EJECUTA DENTRO DE field_projection()]

save_projection_results()                             # Persistencia de resultados
‚îú‚îÄ‚îÄ generate_csv_summary()                            # [EJECUTA DENTRO DE save_projection_results()]
‚îú‚îÄ‚îÄ save_lightcurve_data()                            # [EJECUTA DENTRO DE save_projection_results()]
‚îî‚îÄ‚îÄ update_run_metadata()                             # [EJECUTA DENTRO DE save_projection_results()]
```

---

## ÔøΩüöÄ **PUNTO DE ENTRADA: simple_runner.py**

### **Funci√≥n Principal: `main()`**
```python
def main():
    args = parse_arguments()  # Parsear CLI arguments
    setup_environment()       # Crear directorios de output
    run_custom_batch(...)     # Ejecutar batch con par√°metros CLI
```

### **CLI Arguments ‚Üí SimpleConfig**
```python
def run_custom_batch(n_runs, redshift_max, sn_types, survey, filter_band, seed):
    # 1. CREAR CONFIGURACI√ìN desde CLI
    config = create_simple_config(
        n_runs=n_runs,           # --runs 50
        redshift_max=redshift_max, # --redshift-max 0.3
        sn_types=sn_types,       # --sn-types Ia Ibc
        survey=survey,           # --survey ZTF
        filter_band=filter_band, # --filter r
        base_seed=seed           # --seed 123
    )
    
    # 2. EJECUTAR BATCH CIENT√çFICO
    results = run_scientific_batch(config)  # ‚Üí batch_runner.py
```

**Archivos Involucrados:**
- `simple_runner.py`: Entry point y CLI parsing
- `simple_config.py`: Clase `SimpleConfig` y funci√≥n `create_simple_config()`

---

## üîÑ **BATCH RUNNER: batch_runner.py**

### **Funci√≥n de Alto Nivel: `run_scientific_batch(config)`**
```python
def run_scientific_batch(batch_config) -> Dict:
    runner = ProfessionalBatchRunner()
    return runner.run_batch(batch_config)  # ‚Üê M√©todo principal
```

### **Clase Principal: `ProfessionalBatchRunner`**

#### **M√©todo Central: `run_batch(batch_config)`**
```python
def run_batch(self, batch_config) -> Dict:
    self.stats.start_batch()  # Iniciar cron√≥metro
    
    for i in range(batch_config.n_runs):  # Loop principal de iteraciones
        # 1. GENERAR PAR√ÅMETROS de la iteraci√≥n
        iteration_params = self.create_run_parameters(batch_config, i, batch_config.n_runs)
        
        # 2. EJECUTAR iteraci√≥n individual
        success, iteration_results = self.execute_single_run(iteration_params)
        
        # 3. REGISTRAR resultados
        iteration_record = {**iteration_params, **iteration_results, 'success': success}
        self.run_registry.append(iteration_record)
        
        # 4. ACTUALIZAR estad√≠sticas agregadas
        if success:
            self.stats.add_successful_run(...)
        else:
            self.stats.add_failed_run(...)
    
    # 5. GUARDAR resultados del batch
    self.save_batch_results(batch_config)
    return summary
```

---

## üìä **GENERACI√ìN DE PAR√ÅMETROS: `create_run_parameters()`**

### **Muestreo Cient√≠fico por Iteraci√≥n**
```python
def create_run_parameters(self, batch_config, run_index: int, total_runs: int) -> Dict:
    np.random.seed(batch_config.base_seed + run_index)  # Reproducibilidad
    
    # 1. SELECCIONAR tipo de SN seg√∫n distribuci√≥n
    sn_type = np.random.choice(
        list(batch_config.sn_type_distribution.keys()),
        p=list(batch_config.sn_type_distribution.values())
    )  # ‚Üí "Ia", "Ibc", "II"
    
    # 2. MUESTREO COSMOL√ìGICO (volume-weighted)
    redshift_sample = sample_cosmological_redshift(
        n_samples=1,
        z_min=z_min, z_max=z_max,
        H0=cosmology.get('H0', 70),
        Om=cosmology.get('Om', 0.3),
        OL=cosmology.get('OL', 0.7)
    )[0]  # ‚Üí 0.0249
    
    # 3. EXTINCI√ìN DEL HOST (distribuciones por tipo)
    ebmv_host_sample = sample_extinction_by_type(
        sn_type=sn_type, 
        n_samples=1, 
        random_state=batch_config.base_seed + run_index
    )  # ‚Üí 0.043 (distribuci√≥n exponencial/mixta seg√∫n tipo)
    
    # 4. SELECCIONAR TEMPLATE aleatoriamente
    available_templates = get_sn_templates()[sn_type]
    template = np.random.choice(available_templates)  # ‚Üí "SN2006ep.dat"
    
    # 5. EXTINCI√ìN MW (mapas realistas ZTF)
    ebmv_mw_sample = sample_realistic_mw_extinction(
        sn_name=template.replace('.dat', ''), 
        n_samples=1, 
        random_state=batch_config.base_seed + run_index
    )  # ‚Üí 0.067 (consulta mapas SFD98)
    
    # 6. SELECCIONAR SURVEY
    survey = np.random.choice(
        list(batch_config.survey_distribution.keys()),
        p=list(batch_config.survey_distribution.values())
    )  # ‚Üí "ZTF"
    
    return iteration_params  # Diccionario con todos los par√°metros
```

**Funciones Cient√≠ficas Llamadas:**
- `sample_cosmological_redshift()` ‚Üí `core/correction.py`
- `sample_extinction_by_type()` ‚Üí `core/correction.py`
- `get_sn_templates()` ‚Üí `simple_config.py`
- `sample_realistic_mw_extinction()` ‚Üí `dust_maps.py`

---

## ‚öôÔ∏è **EJECUCI√ìN INDIVIDUAL: `execute_single_run()`**

### **Sistema Robusto con Fallback**
```python
def execute_single_run(self, iteration_params: Dict) -> Tuple[bool, Dict]:
    iteration_start_time = time.time()
    
    try:
        # 1. ACTUALIZAR configuraci√≥n global
        self.update_config_for_run(iteration_params)
        
        # 2. VALIDAR configuraci√≥n
        validated_config = load_and_validate_config()
        
        # 3. M√âTODO PRIMARIO: Ejecuci√≥n directa
        try:
            import main
            main.main(config=validated_config)  # ‚Üê LLAMADA A MAIN.PY
            
            # Extraer estad√≠sticas reales del CSV generado
            real_stats = self.extract_run_statistics(iteration_params)
            return True, iteration_stats
            
        except Exception as direct_error:
            # 4. M√âTODO FALLBACK: Subprocess
            result = subprocess.run([sys.executable, 'main.py'], 
                                  capture_output=True, text=True)
            
            if result.returncode == 0:
                real_stats = self.extract_run_statistics(iteration_params)
                return True, iteration_stats
            else:
                return False, error_details
    
    except Exception as e:
        return False, {'error': str(e)}
```

### **Actualizaci√≥n de Configuraci√≥n: `update_config_for_run()`**
```python
def update_config_for_run(self, iteration_params: Dict) -> None:
    # MODIFICAR variables globales en config.py
    config.SN_CONFIG['sn_name'] = iteration_params['sn_name']        # "SN2006ep"
    config.SN_CONFIG['tipo'] = iteration_params['sn_type']           # "Ibc"
    config.SN_CONFIG['z_proy'] = iteration_params['redshift']        # 0.0249
    config.SN_CONFIG['ebmv_host'] = iteration_params['ebmv_host']    # 0.043
    config.SN_CONFIG['ebmv_mw'] = iteration_params['ebmv_mw']        # 0.067
    config.PATHS['spec_file'] = iteration_params['template_file']    # "Ibc/SN2006ep.dat"
    config.SN_CONFIG['selected_filter'] = iteration_params['filter_band']  # "r"
    config.SURVEY = iteration_params['survey']                       # "ZTF"
```

---

## üî¨ **PIPELINE CIENT√çFICO: main.py**

### **Funci√≥n Principal: `main(config=None)`**
```python
def main(config=None):
    # CONFIGURACI√ìN (si no viene del batch)
    if config is None:
        config = load_and_validate_config()
    
    # Extraer informaci√≥n espec√≠fica
    survey_info = get_survey_info(config)
    sn_info = get_sn_info(config)
    processing_config = config['processing']
    extinction_config = config['extinction']
```

### **PASO 1: Lectura de Espectro**
```python
print(f"\nPASO 1: Lectura de espectro")
ESPECTRO, fases = leer_spec(path_spec, ot=False, as_pandas=True)
# ‚Üí Lista de DataFrames con espectros por fase
# ‚Üí Lista de fases temporales (MJD o d√≠as relativos)
```

### **PASO 2: Correcciones Cosmol√≥gicas y Extinci√≥n**
```python
print(f"\nPASO 2: Correcciones cosmol√≥gicas y extinci√≥n")
ESPECTRO_corr, fases_corr = correct_redeening(
    sn=sn_name, ESPECTRO=ESPECTRO, fases=fases,
    z=z_proy,                    # Redshift de la iteraci√≥n
    ebmv_host=ebmv_host_final,   # Extinci√≥n del host
    ebmv_mw=ebmv_mw,            # Extinci√≥n MW
    reverse=True, use_DL=True
)
# ‚Üí Aplica redshift cosmol√≥gico + extinci√≥n en orden f√≠sico correcto
```

### **PASO 3: Curva de Respuesta del Filtro**
```python
print(f"\nPASO 3: Curva de respuesta del filtro {selected_filter}")
response_df = pd.read_csv(path_response, sep='\s+', comment='#', header=None)
response_df.columns = ['wave', 'response']
# ‚Üí Carga curva de respuesta del filtro fotom√©trico (r, g, i, etc.)
```

### **PASO 4: Fotometr√≠a Sint√©tica**
```python
print(f"\nPASO 4: Fotometr√≠a sint√©tica")
for spec, fase in zip(ESPECTRO_corr, fases_corr):
    flux, porcentaje = Syntetic_photometry_v2(
        spec['wave'].values, spec['flux'].values,
        response_df['wave'].values, response_df['response'].values
    )
    if porcentaje > processing_config['overlap_threshold']:  # 0.95
        fases_lc.append(fase)
        fluxes_lc.append(flux)
# ‚Üí Convoluciona espectros con filtro seg√∫n overlap m√≠nimo
```

### **PASO 5: Suavizado LOESS**
```python
print(f"\nPASO 5: Suavizado LOESS")
df_loess = Loess_fit(LC_df, selected_filter, 
                    alpha=alpha_usado, plot=False)
# ‚Üí Suavizado estad√≠stico para interpolar curva de luz
```

### **PASO 6: Calibraci√≥n Fotom√©trica**
```python
print(f"\nPASO 6: Calibraci√≥n fotom√©trica")
constante = 'cte' + selected_filter  # cter, cteg, cteV, etc.
mul = arr_val_ctes[jj]              # Constante de punto cero
flux_calibrado = np.array(lc_df['flux']) / mul
mag = -2.5 * np.log10(np.clip(flux_calibrado, 1e-20, None))
# ‚Üí Convierte flujos a magnitudes calibradas
```

### **PASO 7: Ruido Fotom√©trico**
```python
print(f"\nPASO 7: Aplicaci√≥n de ruido fotom√©trico")
noise_level = processing_config['noise_level']  # 0.15 (15%)
flux_noisy_norm = np.random.normal(
    loc=flux_norm, 
    scale=np.sqrt(np.abs(flux_norm)) * noise_level
)
mag_noisy = -2.5 * np.log10(flux_noisy)
# ‚Üí Simula ruido de Poisson con distribuci√≥n gaussiana
```

### **PASO 7.5: Conversi√≥n de Unidades Temporales (CR√çTICO)**
```python
maximum = maximo_lc(tipo, sn_name)  # MJD del m√°ximo
if tipo in ['Ibc', 'Ib', 'Ic']:     # SNe core-collapse
    mjd_absolute = maximum + lc_df['fase']  # Fases relativas ‚Üí MJD absoluto
    lc_df['fase'] = mjd_absolute            # Actualizar DataFrame
```

**‚ö†Ô∏è BUG CR√çTICO RESUELTO:**
```python
# ANTES (INCORRECTO):
# fases = [-10, 0, +20]        # ‚Üê Fases relativas
# maximum = 53671              # ‚Üê MJD absoluto  
# mjd_pivote = 59000          # ‚Üê MJD modernas ZTF
# desplazamiento = 59000 - 53671 + offset ‚âà 5329 d√≠as
# fases_ajustadas = [5319, 5329, 5349]  # ‚Üê ¬°Fechas imposibles a√±o 1846!

# DESPU√âS (CORRECTO):
# fases_convertidas = [53659, 53671, 53691]  # ‚Üê MJD absoluto
# fases_ajustadas = [58988, 59000, 59089]    # ‚Üê Fechas modernas v√°lidas
```

### **PASO 8: Proyecci√≥n sobre Observaciones Reales**
```python
print(f"\nPASO 8: Proyecci√≥n sobre observaciones reales ({SURVEY})")
df_obslog_survey = pd.read_csv(path_obslog)

# Selecci√≥n de target espec√≠fica
if SURVEY == "ZTF":
    available_targets = df_obslog_survey[target_column].unique()
    selected_target = np.random.choice(available_targets)  # OID aleatorio

df_projected = field_projection(
    fases=lc_df['fase'].values,          # MJD absoluto (ya convertido)
    flux_y=mag_noisy,                    # Magnitudes con ruido
    df_obslog=df_obslog_survey,          # Observaciones reales del survey
    tipo=tipo,                           # Tipo SN para calcular m√°ximo
    selected_filter=projection_filter,   # Filtro espec√≠fico del survey
    selected_field=selected_target,      # Target seleccionado
    offset=np.arange(offset_range[0], offset_range[1], offset_step),
    sn=sn_name,
    plot=show_debug_plots
)
```

### **Funci√≥n `field_projection()` (core/projection.py):**
```python
def field_projection(fases, flux_y, df_obslog, tipo, selected_filter, 
                    offset, sn, selected_field=None, plot=False):
    # 1. FILTRAR observaciones por campo/OID y filtro
    df_filtered = obs_log[
        (obs_log['field/oid'] == selected_field) &
        (obs_log['filter'] == selected_filter)
    ]
    
    # 2. CALCULAR m√°ximo de la SN
    maximum = maximo_lc(tipo, sn)
    
    # 3. SELECCIONAR offset aleatorio y calcular desplazamiento
    select_offset = np.random.choice(offset)
    mjd_pivote = df_filtered.iloc[0]['mjd']
    desplazamiento = mjd_pivote - maximum + select_offset
    
    # 4. AJUSTAR fases de la SN al tiempo de observaci√≥n
    fases_ajustadas = [fecha + desplazamiento for fecha in fases]
    
    # 5. FILTRAR observaciones que coinciden temporalmente
    df_filtered_cut = df_filtered[
        (df_filtered['mjd'] >= min(fases_ajustadas)) &
        (df_filtered['mjd'] <= max(fases_ajustadas))
    ]
    
    # 6. INTERPOLAR magnitudes de la SN en tiempos de observaci√≥n
    interpolation_function = interpolate.interp1d(
        fases_ajustadas, flux_y, kind='linear', fill_value='extrapolate'
    )
    df_filtered_cut['magnitud_proyectada'] = interpolation_function(df_filtered_cut['mjd'])
    
    # 7. CLASIFICAR detecciones vs upper limits
    df_filtered_cut['upperlimit'] = (
        df_filtered_cut['maglimit'] == df_filtered_cut['magnitud_proyectada']
    ).map({True: 'T', False: 'F'})
    
    return df_filtered_cut  # DataFrame con proyecciones finales
```

### **PASO 9: Resultados Finales**
```python
print(f"\nPASO 9: Resultados finales ({SURVEY})")
if len(df_projected) > 0:
    detecciones = len(df_projected[df_projected['upperlimit'] == 'F'])
    upper_limits = len(df_projected[df_projected['upperlimit'] == 'T'])
    tasa_deteccion = detecciones/len(df_projected)*100
    
    print(f"   ‚Ä¢ Detecciones: {detecciones:,}")
    print(f"   ‚Ä¢ Upper limits: {upper_limits:,}")
    print(f"   ‚Ä¢ Tasa de detecci√≥n: {tasa_deteccion:.1f}%")
```

### **PASO 10: Guardar Resultados**
```python
print(f"\nPASO 10: Guardar Resultados")
saved_files = save_projection_results(
    df_projected=df_projected,      # Proyecciones finales
    lc_df=lc_df,                   # Curva de luz sint√©tica
    mag=mag,                       # Magnitudes limpias
    mag_noisy=mag_noisy,           # Magnitudes con ruido
    survey_params=survey_params,    # Metadatos del survey
    sn_params=sn_params,           # Par√°metros f√≠sicos SN
    projection_params=projection_params,  # Config t√©cnica
    ruido_promedio=ruido_promedio,
    alpha_usado=alpha_usado,
    maximum=maximum
)
```

### **PASO 11: Actualizar √çndice Maestro**
```python
print(f"\nPASO 11: Actualizar √çndice Maestro")
create_master_index()  # Actualiza √≠ndice global de simulaciones
```

---

## üìä **RETORNO Y AGREGACI√ìN**

### **Extracci√≥n de Estad√≠sticas: `extract_run_statistics()`**
```python
def extract_run_statistics(self, iteration_params: Dict) -> Dict:
    # 1. BUSCAR archivo summary m√°s reciente
    search_pattern = f"outputs/**/summary_*{sn_name}*.csv"
    summary_files = glob.glob(search_pattern, recursive=True)
    
    # 2. LEER CSV generado por main.py
    df_summary = pd.read_csv(summary_file)
    row = df_summary.iloc[0]
    
    # 3. EXTRAER m√©tricas reales
    return {
        'n_detections': int(row.get('detections', 0)),      # 29
        'n_observations': int(row.get('total_points', 0)),  # 29  
        'detection_rate_percent': float(row.get('detection_rate_percent', 0.0)),  # 100.0
        'ebmv_host': float(row.get('ebmv_host', 0.0)),      # 0.043
        'ebmv_mw': float(row.get('ebmv_mw', 0.0)),          # 0.067
        'status': row.get('status', 'UNKNOWN')              # "SUCCESS"
    }
```

### **Agregaci√≥n de Estad√≠sticas: `add_successful_run()`**
```python
def add_successful_run(self, execution_time: float, n_detections: int, 
                      n_observations: int, sn_type: str):
    self.runs_completed += 1
    self.execution_times.append(execution_time)        # Para promedios
    self.total_detections += n_detections              # Suma global
    self.total_observations += n_observations          # Suma global
    
    # Estad√≠sticas por tipo de SN
    if sn_type not in self.detection_rates_by_type:
        self.detection_rates_by_type[sn_type] = []
    
    detection_rate = n_detections / max(1, n_observations)
    self.detection_rates_by_type[sn_type].append(detection_rate)
```

---

## üìÅ **ESTRUCTURA DE OUTPUTS GENERADA**

### **Archivos Individuales (main.py):**
```
outputs/single_runs/run_20250816_143052_SN2006ep/
‚îú‚îÄ‚îÄ projection_results.csv      ‚Üê Detecciones/upper limits por observaci√≥n
‚îú‚îÄ‚îÄ metadata.json               ‚Üê Par√°metros completos de la simulaci√≥n
‚îú‚îÄ‚îÄ lightcurve_plot.png         ‚Üê Gr√°fico cient√≠fico curva de luz
‚îú‚îÄ‚îÄ projection_plot.png         ‚Üê Gr√°fico temporal de proyecci√≥n
‚îî‚îÄ‚îÄ summary_SN2006ep_Ibc.csv    ‚Üê Resumen de 1 fila con m√©tricas clave
```

### **Archivos Agregados (batch_runner.py):**
```
outputs/batch_runs/batch_20250816_142830_a1b2c3d4/
‚îú‚îÄ‚îÄ batch_metadata.json         ‚Üê Configuraci√≥n + estad√≠sticas agregadas
‚îú‚îÄ‚îÄ run_summary.csv             ‚Üê Todas las iteraciones en 1 DataFrame
‚îú‚îÄ‚îÄ statistical_summary.txt     ‚Üê Resumen cient√≠fico legible
‚îî‚îÄ‚îÄ logs/batch_[ID].log         ‚Üê Log completo del batch
```

---

## üîÑ **DIAGRAMA DE FLUJO COMPLETO**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   CLI INPUTS    ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ SIMPLE_RUNNER   ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ SIMPLE_CONFIG   ‚îÇ
‚îÇ --runs 50       ‚îÇ    ‚îÇ parse_arguments ‚îÇ    ‚îÇ create_simple_  ‚îÇ
‚îÇ --filter r      ‚îÇ    ‚îÇ setup_env       ‚îÇ    ‚îÇ config()        ‚îÇ
‚îÇ --sn-types Ibc  ‚îÇ    ‚îÇ run_custom_batch‚îÇ    ‚îÇ SimpleConfig    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                        ‚îÇ
                                                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ BATCH_RUNNER    ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ run_scientific_ ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ CONFIG OBJECT   ‚îÇ
‚îÇ Professional    ‚îÇ    ‚îÇ batch()         ‚îÇ    ‚îÇ n_runs=50       ‚îÇ
‚îÇ BatchRunner     ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ sn_types=["Ibc"]‚îÇ
‚îÇ                 ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ filter_band="r" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ
          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PARAMETER       ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ SINGLE RUN      ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ MAIN.PY         ‚îÇ
‚îÇ GENERATION      ‚îÇ    ‚îÇ EXECUTION       ‚îÇ    ‚îÇ PIPELINE        ‚îÇ
‚îÇ create_run_     ‚îÇ    ‚îÇ execute_single_ ‚îÇ    ‚îÇ main()          ‚îÇ
‚îÇ parameters()    ‚îÇ    ‚îÇ run()           ‚îÇ    ‚îÇ                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                      ‚îÇ                      ‚îÇ
          ‚ñº                      ‚ñº                      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ SCIENTIFIC      ‚îÇ    ‚îÇ CONFIG UPDATE   ‚îÇ    ‚îÇ 11 PASOS        ‚îÇ
‚îÇ SAMPLING        ‚îÇ    ‚îÇ update_config_  ‚îÇ    ‚îÇ CIENT√çFICOS     ‚îÇ
‚îÇ ‚Ä¢ Cosmology     ‚îÇ    ‚îÇ for_run()       ‚îÇ    ‚îÇ ‚Ä¢ Espectros     ‚îÇ
‚îÇ ‚Ä¢ Extinction    ‚îÇ    ‚îÇ ‚Ä¢ sn_name       ‚îÇ    ‚îÇ ‚Ä¢ Correcciones  ‚îÇ
‚îÇ ‚Ä¢ Templates     ‚îÇ    ‚îÇ ‚Ä¢ redshift      ‚îÇ    ‚îÇ ‚Ä¢ Fotometr√≠a    ‚îÇ
‚îÇ ‚Ä¢ Coordinates   ‚îÇ    ‚îÇ ‚Ä¢ extinctions   ‚îÇ    ‚îÇ ‚Ä¢ Proyecci√≥n    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                                        ‚îÇ
                                                        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ RESULTS         ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ STATISTICS      ‚îÇ‚óÄ‚îÄ‚îÄ‚îÄ‚îÇ OUTPUTS         ‚îÇ
‚îÇ AGGREGATION     ‚îÇ    ‚îÇ EXTRACTION      ‚îÇ    ‚îÇ ‚Ä¢ CSV files     ‚îÇ
‚îÇ ‚Ä¢ Total detect  ‚îÇ    ‚îÇ extract_run_    ‚îÇ    ‚îÇ ‚Ä¢ JSON metadata ‚îÇ
‚îÇ ‚Ä¢ By SN type    ‚îÇ    ‚îÇ statistics()    ‚îÇ    ‚îÇ ‚Ä¢ Plots         ‚îÇ
‚îÇ ‚Ä¢ Success rate  ‚îÇ    ‚îÇ                 ‚îÇ    ‚îÇ ‚Ä¢ Logs          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîß **FUNCIONES CLAVE POR ARCHIVO**

### **simple_runner.py**
- `main()`: Entry point principal
- `parse_arguments()`: Parseo CLI
- `setup_environment()`: Creaci√≥n directorios
- `run_custom_batch()`: Configuraci√≥n y ejecuci√≥n

### **simple_config.py**
- `create_simple_config()`: Factory de configuraciones
- `get_sn_templates()`: Obtener templates por tipo
- `SimpleConfig`: Clase de configuraci√≥n

### **batch_runner.py**
- `ProfessionalBatchRunner.run_batch()`: Loop principal
- `create_run_parameters()`: Muestreo cient√≠fico
- `execute_single_run()`: Ejecuci√≥n individual
- `update_config_for_run()`: Actualizaci√≥n config
- `extract_run_statistics()`: Extracci√≥n m√©tricas
- `save_batch_results()`: Persistencia agregada

### **main.py**
- `main()`: Pipeline cient√≠fico 11 pasos
- Funciones de cada paso detalladas arriba

### **core/projection.py**
- `field_projection()`: Proyecci√≥n temporal core

### **core/correction.py**
- `sample_cosmological_redshift()`: Muestreo cosmol√≥gico
- `sample_extinction_by_type()`: Distribuciones extinci√≥n
- `correct_redeening()`: Aplicaci√≥n correcciones

### **core/utils.py**
- `leer_spec()`: Lectura espectros
- `Syntetic_photometry_v2()`: Fotometr√≠a sint√©tica
- `Loess_fit()`: Suavizado estad√≠stico
- `maximo_lc()`: Fecha del m√°ximo

---

## ‚ö†Ô∏è **PUNTOS CR√çTICOS DOCUMENTADOS**

### **1. Bug de Unidades Temporales (RESUELTO)**
- **Problema**: Fases relativas vs MJD absoluto en proyecci√≥n
- **Soluci√≥n**: PASO 7.5 conversi√≥n expl√≠cita
- **Ubicaci√≥n**: `main.py` l√≠neas 200-210

### **2. Sistema de Fallback**
- **M√©todo primario**: Import directo `main.main()`
- **M√©todo fallback**: Subprocess `python main.py`
- **Raz√≥n**: Aislamiento de estado entre iteraciones

### **3. Configuraci√≥n Global**
- **Actualizaci√≥n**: `update_config_for_run()` modifica `config.py`
- **Validaci√≥n**: `load_and_validate_config()` lee valores actualizados
- **Consistencia**: Ambos m√©todos (directo/subprocess) ven misma config

### **4. Extracci√≥n de Estad√≠sticas**
- **Fuente**: CSV generado por `save_projection_results()`
- **Timing**: Despu√©s de completar `main.main()`
- **Validaci√≥n**: Confirma ejecuci√≥n exitosa vs fallida

---

## üìà **M√âTRICAS CIENT√çFICAS GENERADAS**

### **Por Iteraci√≥n Individual:**
- `n_detections`: N√∫mero de detecciones
- `n_observations`: Observaciones totales  
- `detection_rate_percent`: Tasa de detecci√≥n
- `execution_time`: Tiempo de ejecuci√≥n
- `ebmv_host`, `ebmv_mw`: Extinciones aplicadas

### **Agregadas por Batch:**
- `total_detections`: Suma de todas las detecciones
- `global_detection_rate`: Tasa global
- `detection_rates_by_type`: Distribuciones por tipo SN
- `success_rate`: Tasa de √©xito de simulaciones
- `average_execution_time`: Tiempo promedio

### **Distribuciones Estad√≠sticas:**
- Media, desviaci√≥n est√°ndar, mediana por tipo SN
- Rangos de redshift, extinci√≥n, magnitudes
- Cobertura temporal y espacial

---

##  **DISE√ëO PARA INVESTIGACI√ìN **

### **Reproducibilidad Cient√≠fica:**
- Seeds controladas para cada iteraci√≥n
- Configuraciones completas guardadas
- Trazabilidad end-to-end documentada

### **Escalabilidad:**
- Paralelizaci√≥n futura posible
- Manejo robusto de errores
- Logging detallado para debugging

### **Validaci√≥n Acad√©mica:**
- Referencias cient√≠ficas en distribuciones
- M√©todos observacionalmente validados
- Estad√≠sticas publication-ready

---

**SISTEMA COMPLETO MAPEADO** ‚úÖ  
*Documentaci√≥n t√©cnica completa para referencia permanente*  
*Actualizado: Agosto 2025*
